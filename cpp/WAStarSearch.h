#pragma once
#include <vector>
#include <set>
#include <functional>
#include <unordered_map>
#include "utility/PriorityQueue.h"
#include "utility/WAStarResult.h"
#include "expansionAlgorithms/WAStar.h"
#include "domain/SlidingTilePuzzle.h"

using namespace std;

template<class Domain>
class WAStarSearch
{
public:
    typedef typename SlidingTilePuzzle::State State;
    typedef typename SlidingTilePuzzle::Cost Cost;
    typedef typename SlidingTilePuzzle::HashState Hash;

    struct Node {
        Cost g;
        Cost h;
        Node* parent;
        State stateRep;

    public:
        Cost getGValue() const { return g; }
        Cost getHValue() const { return h; }
        Cost getFValue() const { return g + h; }
        State getState() const { return stateRep; }
        Node* getParent() const { return parent; }

        void setHValue(Cost val) { h = val; }
        void setGValue(Cost val) { g = val; }
        void setState(State s) { stateRep = s; }
        void setParent(Node* p) { parent = p; }

        Node(Cost g, Cost h, State state, Node* parent)
                : g(g), h(h), stateRep(state), parent(parent) {}

        friend std::ostream& operator<<(std::ostream& stream,
                const Node& node) {
            stream << node.getState() << endl;
            stream << "f: " << node.getFValue() << endl;
            stream << "g: " << node.getGValue() << endl;
            stream << "h: " << node.getHValue() << endl;
            stream << "action generated by: " << node.getState().getLabel()
                   << endl;
            stream << "-----------------------------------------------" << endl;
            stream << endl;
            return stream;
        }

        static bool compareNodesF(const Node* n1, const Node* n2) {
            // Tie break on g-value
            if (n1->getFValue() == n2->getFValue()) {
                return n1->getGValue() > n2->getGValue();
            }
            return n1->getFValue() < n2->getFValue();
        }

    };

    WAStarSearch(SlidingTilePuzzle& domain,
            float weight)
            : domain(domain),
              weight(weight) {
        wastar =
                new WAStar<SlidingTilePuzzle, Node>(domain, weight, "f");
         }

    ~WAStarSearch() { clean(); }

    WAStarResult search() {
        WAStarResult res;

        // Get the start node
        Node* cur = new Node(0,
                domain.heuristic(domain.getStartState()),
                domain.getStartState(),
                NULL);

        // Expand some nodes
        wastar->expand(open, closed, duplicateDetection, res);

        return res;
	}

private:
    static bool duplicateDetection(Node* node,
            unordered_map<State, Node*, Hash>& closed,
            PriorityQueue<Node*>& open) {
        // Check if this state exists
        typename unordered_map<State, Node*, Hash>::iterator it =
                closed.find(node->getState());

        if (it != closed.end()) {
            // This state has been generated before, check if its node is on
            // OPEN
            if (it->second->onOpen()) {
                // This node is on OPEN, keep the better g-value
                if (node->getGValue() < it->second->getGValue()) {
                    it->second->setGValue(node->getGValue());
                    it->second->setParent(node->getParent());
                    it->second->setHValue(node->getHValue());
                    it->second->setDValue(node->getDValue());
                    it->second->setDErrValue(node->getDErrValue());
                    it->second->setEpsilonH(node->getEpsilonH());
                    it->second->setEpsilonD(node->getEpsilonD());
                    it->second->setState(node->getState());
                    it->second->setOwningTLA(node->getOwningTLA());
                    return true;
                }
            } else {
                // This node is on CLOSED, compare the f-values. If this new
                // f-value is better, reset g, h, and d. 
				// We don't reopen the node for weighted A*.
            }

        }

        return false;
    }

    void clean() {
        // Empty OPEN and CLOSED
        open.clear();

        // delete all of the nodes from the last expansion phase
        for (typename unordered_map<State, Node*, Hash>::iterator it =
                        closed.begin();
                it != closed.end();
                it++)
            delete it->second;

        closed.clear();

        delete wastar;
    }

    void calculateCost(Node* solution, ResultContainer& res) {
        res.solutionFound = true;
        res.solutionCost = solution->getFValue();
    }

protected:
    SlidingTilePuzzle& domain;
    WAStar<Domain, Node>* wastar;
    PriorityQueue<Node*> open;
    unordered_map<State, Node*, Hash> closed;

    float weight;
};
